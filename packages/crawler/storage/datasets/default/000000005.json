{
	"title": "Text generation - OpenAI API",
	"url": "https://platform.openai.com/docs/guides/text-generation",
	"html": "Overview\nDocumentation\nAPI reference\nExamples\nLog in\nSign up‍\nSearch\n⌘\nK\nGET STARTED\nIntroduction\nQuickstart\nModels\nTutorials\nChangelog\nCAPABILITIES\nText generation\nChat Completions\nJSON mode\nReproducible outputs\nManaging tokens\nCompletions API (Legacy)\nFAQ\nFunction calling\nEmbeddings\nFine-tuning\nImage generation\nVision\nText-to-speech\nSpeech-to-text\nModeration\nASSISTANTS\nOverview\nHow Assistants work\nTools\nGUIDES\nPrompt engineering\nProduction best practices\nSafety best practices\nRate limits\nError codes\nLibraries\nDeprecations\nPolicies\nCHATGPT\nActions\nPlugins\nText generation models\n\nNew capabilities launched at DevDay\n\nText generation models are now capable of JSON mode and Reproducible outputs. We also launched the Assistants API to enable you to build agent-like experiences on top of our text-generation models. GPT-4 Turbo is available in preview by specifying gpt-4-1106-preview as the model name.\n\nOpenAI's text generation models (often called generative pre-trained transformers or large language models) have been trained to understand natural language, code, and images. The models provide text outputs in response to their inputs. The inputs to these models are also referred to as \"prompts\". Designing a prompt is essentially how you “program” a large language model model, usually by providing instructions or some examples of how to successfully complete a task.\n\nUsing OpenAI's text generation models, you can build applications to:\n\nDraft documents\nWrite computer code\nAnswer questions about a knowledge base\nAnalyze texts\nGive software a natural language interface\nTutor in a range of subjects\nTranslate languages\nSimulate characters for games\n\nWith the release of gpt-4-vision-preview, you can now build systems that also process and understand images.\n\nExplore GPT-4 with image inputs\nCheck out the vision guide for more detail.\nGPT-4 Turbo\nTry out GPT-4 Turbo in the playground.\n\nTo use one of these models via the OpenAI API, you’ll send a request containing the inputs and your API key, and receive a response containing the model’s output. Our latest models, gpt-4 and gpt-3.5-turbo, are accessed through the chat completions API endpoint.\n\n\tMODEL FAMILIES\tAPI ENDPOINT\nNewer models (2023–)\tgpt-4, gpt-4 turbo, gpt-3.5-turbo\thttps://api.openai.com/v1/chat/completions\nUpdated legacy models (2023)\tgpt-3.5-turbo-instruct, babbage-002, davinci-002\thttps://api.openai.com/v1/completions\nLegacy models (2020–2022)\ttext-davinci-003, text-davinci-002, davinci, curie, babbage, ada\thttps://api.openai.com/v1/completions\n\nYou can experiment with various models in the chat playground. If you’re not sure which model to use, then use gpt-3.5-turbo or gpt-4.\n\nChat Completions API\n\nChat models take a list of messages as input and return a model-generated message as output. Although the chat format is designed to make multi-turn conversations easy, it’s just as useful for single-turn tasks without any conversation.\n\nAn example Chat Completions API call looks like the following:\n\npython\nSelect library\npython\nnode.js\ncurl\nCopy‍\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\nfrom openai import OpenAI\nclient = OpenAI()\n\nresponse = client.chat.completions.create(\n  model=\"gpt-3.5-turbo\",\n  messages=[\n    {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n    {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n    {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n    {\"role\": \"user\", \"content\": \"Where was it played?\"}\n  ]\n)\n\nTo learn more, you can view the full API reference documentation for the Chat API.\n\nThe main input is the messages parameter. Messages must be an array of message objects, where each object has a role (either \"system\", \"user\", or \"assistant\") and content. Conversations can be as short as one message or many back and forth turns.\n\nTypically, a conversation is formatted with a system message first, followed by alternating user and assistant messages.\n\nThe system message helps set the behavior of the assistant. For example, you can modify the personality of the assistant or provide specific instructions about how it should behave throughout the conversation. However note that the system message is optional and the model’s behavior without a system message is likely to be similar to using a generic message such as \"You are a helpful assistant.\"\n\nThe user messages provide requests or comments for the assistant to respond to. Assistant messages store previous assistant responses, but can also be written by you to give examples of desired behavior.\n\nIncluding conversation history is important when user instructions refer to prior messages. In the example above, the user’s final question of \"Where was it played?\" only makes sense in the context of the prior messages about the World Series of 2020. Because the models have no memory of past requests, all relevant information must be supplied as part of the conversation history in each request. If a conversation cannot fit within the model’s token limit, it will need to be shortened in some way.\n\nTo mimic the effect seen in ChatGPT where the text is returned iteratively, set the stream parameter to true.\nChat Completions response format\n\nAn example Chat Completions API response looks as follows:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n{\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"message\": {\n        \"content\": \"The 2020 World Series was played in Texas at Globe Life Field in Arlington.\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1677664795,\n  \"id\": \"chatcmpl-7QyqpwdfhqwajicIEznoc6Q47XAyW\",\n  \"model\": \"gpt-3.5-turbo-0613\",\n  \"object\": \"chat.completion\",\n  \"usage\": {\n    \"completion_tokens\": 17,\n    \"prompt_tokens\": 57,\n    \"total_tokens\": 74\n  }\n}\n\nThe assistant’s reply can be extracted with:\n\npython\nSelect library\npython\nnode.js\nCopy‍\nresponse['choices'][0]['message']['content']\n\nEvery response will include a finish_reason. The possible values for finish_reason are:\n\nstop: API returned complete message, or a message terminated by one of the stop sequences provided via the stop parameter\nlength: Incomplete model output due to max_tokens parameter or token limit\nfunction_call: The model decided to call a function\ncontent_filter: Omitted content due to a flag from our content filters\nnull: API response still in progress or incomplete\n\nDepending on input parameters, the model response may include different information.\n\nJSON mode New\n\nA common way to use Chat Completions is to instruct the model to always return a JSON object that makes sense for your use case, by specifying this in the system message. While this does work in some cases, occasionally the models may generate output that does not parse to valid JSON objects.\n\nTo prevent these errors and improve model performance, when calling gpt-4-1106-preview or gpt-3.5-turbo-1106, you can set response_format to { \"type\": \"json_object\" } to enable JSON mode. When JSON mode is enabled, the model is constrained to only generate strings that parse into valid JSON object.\n\nImportant notes:\n\nWhen using JSON mode, always instruct the model to produce JSON via some message in the conversation, for example via your system message. If you don't include an explicit instruction to generate JSON, the model may generate an unending stream of whitespace and the request may run continually until it reaches the token limit. To help ensure you don't forget, the API will throw an error if the string \"JSON\" does not appear somewhere in the context.\nThe JSON in the message the model returns may be partial (i.e. cut off) if finish_reason is length, which indicates the generation exceeded max_tokens or the conversation exceeded the token limit. To guard against this, check finish_reason before parsing the response.\nJSON mode will not guarantee the output matches any specific schema, only that it is valid and parses without errors.\npython\nSelect library\npython\nnode.js\ncurl\nCopy‍\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\nfrom openai import OpenAI\nclient = OpenAI()\n\nresponse = client.chat.completions.create(\n  model=\"gpt-3.5-turbo-1106\",\n  response_format={ \"type\": \"json_object\" },\n  messages=[\n    {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output JSON.\"},\n    {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"}\n  ]\n)\nprint(response.choices[0].message.content)\n\nIn this example, the response includes a JSON object that looks something like the following:\n\n\"content\": \"{\\\"winner\\\": \\\"Los Angeles Dodgers\\\"}\"`\n\nNote that JSON mode is always enabled when the model is generating arguments as part of function calling.\n\nReproducible outputs Beta\n\nChat Completions are non-deterministic by default (which means model outputs may differ from request to request). That being said, we offer some control towards deterministic outputs by giving you access to the seed parameter and the system_fingerprint response field.\n\nTo receive (mostly) deterministic outputs across API calls, you can:\n\nSet the seed parameter to any integer of your choice and use the same value across requests you'd like deterministic outputs for.\nEnsure all other parameters (like prompt or temperature) are the exact same across requests.\n\nSometimes, determinism may be impacted due to necessary changes OpenAI makes to model configurations on our end. To help you keep track of these changes, we expose the system_fingerprint field. If this value is different, you may see different outputs due to changes we've made on our systems.\n\nDeterministic outputs\nExplore the new seed parameter in the OpenAI cookbook\nManaging tokens\n\nLanguage models read and write text in chunks called tokens. In English, a token can be as short as one character or as long as one word (e.g., a or apple), and in some languages tokens can be even shorter than one character or even longer than one word.\n\nFor example, the string \"ChatGPT is great!\" is encoded into six tokens: [\"Chat\", \"G\", \"PT\", \" is\", \" great\", \"!\"].\n\nThe total number of tokens in an API call affects:\n\nHow much your API call costs, as you pay per token\nHow long your API call takes, as writing more tokens takes more time\nWhether your API call works at all, as total tokens must be below the model’s maximum limit (4097 tokens for gpt-3.5-turbo)\n\nBoth input and output tokens count toward these quantities. For example, if your API call used 10 tokens in the message input and you received 20 tokens in the message output, you would be billed for 30 tokens. Note however that for some models the price per token is different for tokens in the input vs. the output (see the pricing page for more information).\n\nTo see how many tokens are used by an API call, check the usage field in the API response (e.g., response['usage']['total_tokens']).\n\nChat models like gpt-3.5-turbo and gpt-4 use tokens in the same way as the models available in the completions API, but because of their message-based formatting, it's more difficult to count how many tokens will be used by a conversation.\n\nDEEP DIVE\nCounting tokens for chat API calls\n\nTo see how many tokens are in a text string without making an API call, use OpenAI’s tiktoken Python library. Example code can be found in the OpenAI Cookbook’s guide on how to count tokens with tiktoken.\n\nEach message passed to the API consumes the number of tokens in the content, role, and other fields, plus a few extra for behind-the-scenes formatting. This may change slightly in the future.\n\nIf a conversation has too many tokens to fit within a model’s maximum limit (e.g., more than 4097 tokens for gpt-3.5-turbo), you will have to truncate, omit, or otherwise shrink your text until it fits. Beware that if a message is removed from the messages input, the model will lose all knowledge of it.\n\nNote that very long conversations are more likely to receive incomplete replies. For example, a gpt-3.5-turbo conversation that is 4090 tokens long will have its reply cut off after just 6 tokens.\n\nParameter details\n\nFrequency and presence penalties\n\nThe frequency and presence penalties found in the Chat Completions API and Legacy Completions API can be used to reduce the likelihood of sampling repetitive sequences of tokens. They work by directly modifying the logits (un-normalized log-probabilities) with an additive contribution.\n\nmu[j] -> mu[j] - c[j] * alpha_frequency - float(c[j] > 0) * alpha_presence\n\nWhere:\n\nmu[j] is the logits of the j-th token\nc[j] is how often that token was sampled prior to the current position\nfloat(c[j] > 0) is 1 if c[j] > 0 and 0 otherwise\nalpha_frequency is the frequency penalty coefficient\nalpha_presence is the presence penalty coefficient\n\nAs we can see, the presence penalty is a one-off additive contribution that applies to all tokens that have been sampled at least once and the frequency penalty is a contribution that is proportional to how often a particular token has already been sampled.\n\nReasonable values for the penalty coefficients are around 0.1 to 1 if the aim is to just reduce repetitive samples somewhat. If the aim is to strongly suppress repetition, then one can increase the coefficients up to 2, but this can noticeably degrade the quality of samples. Negative values can be used to increase the likelihood of repetition.\n\nCompletions API Legacy\n\nThe completions API endpoint received its final update in July 2023 and has a different interface than the new chat completions endpoint. Instead of the input being a list of messages, the input is a freeform text string called a prompt.\n\nAn example API call looks as follows:\n\npython\nSelect library\npython\nnode.js\nCopy‍\n1\n2\n3\n4\n5\n6\n7\n\nfrom openai import OpenAI\nclient = OpenAI()\n\nresponse = client.completions.create(\n  model=\"gpt-3.5-turbo-instruct\",\n  prompt=\"Write a tagline for an ice cream shop.\"\n)\n\nSee the full API reference documentation to learn more.\n\nToken log probabilities\n\nThe completions API can provide a limited number of log probabilities associated with the most likely tokens for each output token. This feature is controlled by using the logprobs field. This can be useful in some cases to assess the confidence of the model in its output.\n\nInserting text\n\nThe completions endpoint also supports inserting text by providing a suffix in addition to the standard prompt which is treated as a prefix. This need naturally arises when writing long-form text, transitioning between paragraphs, following an outline, or guiding the model towards an ending. This also works on code, and can be used to insert in the middle of a function or file.\n\nDEEP DIVE\nInserting text\nCompletions response format\n\nAn example completions API response looks as follows:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n{\n  \"choices\": [\n    {\n      \"finish_reason\": \"length\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"text\": \"\\n\\n\\\"Let Your Sweet Tooth Run Wild at Our Creamy Ice Cream Shack\"\n    }\n  ],\n  \"created\": 1683130927,\n  \"id\": \"cmpl-7C9Wxi9Du4j1lQjdjhxBlO22M61LD\",\n  \"model\": \"gpt-3.5-turbo-instruct\",\n  \"object\": \"text_completion\",\n  \"usage\": {\n    \"completion_tokens\": 16,\n    \"prompt_tokens\": 10,\n    \"total_tokens\": 26\n  }\n}\n\nIn Python, the output can be extracted with response['choices'][0]['text'].\n\nThe response format is similar to the response format of the Chat Completions API but also includes the optional field logprobs.\n\nChat Completions vs. Completions\n\nThe Chat Completions format can be made similar to the completions format by constructing a request using a single user message. For example, one can translate from English to French with the following completions prompt:\n\nTranslate the following English text to French: \"{text}\"\n\nAnd an equivalent chat prompt would be:\n\n[{\"role\": \"user\", \"content\": 'Translate the following English text to French: \"{text}\"'}]\n\nLikewise, the completions API can be used to simulate a chat between a user and an assistant by formatting the input accordingly.\n\nThe difference between these APIs is the underlying models that are available in each. The chat completions API is the interface to our most capable model (gpt-4), and our most cost effective model (gpt-3.5-turbo).\n\nWhich model should I use?\n\nWe generally recommend that you use either gpt-4 or gpt-3.5-turbo. Which of these you should use depends on the complexity of the tasks you are using the models for. gpt-4 generally performs better on a wide range of evaluations. In particular, gpt-4 is more capable at carefully following complex instructions. By contrast gpt-3.5-turbo is more likely to follow just one part of a complex multi-part instruction. gpt-4 is less likely than gpt-3.5-turbo to make up information, a behavior known as \"hallucination\". gpt-4 also has a larger context window with a maximum size of 8,192 tokens compared to 4,096 tokens for gpt-3.5-turbo. However, gpt-3.5-turbo returns outputs with lower latency and costs much less per token.\n\nWe recommend experimenting in the playground to investigate which models provide the best price performance trade-off for your usage. A common design pattern is to use several distinct query types which are each dispatched to the model appropriate to handle them.\n\nPrompt engineering\n\nAn awareness of the best practices for working with OpenAI models can make a significant difference in application performance. The failure modes that each exhibit and the ways of working around or correcting those failure modes are not always intuitive. There is an entire field related to working with language models which has come to be known as \"prompt engineering\", but as the field has progressed its scope has outgrown merely engineering the prompt into engineering systems that use model queries as components. To learn more, read our guide on prompt engineering which covers methods to improve model reasoning, reduce the likelihood of model hallucinations, and more. You can also find many useful resources including code samples in the OpenAI Cookbook.\n\nFAQ\nHow should I set the temperature parameter?\n\nLower values for temperature result in more consistent outputs (e.g. 0.2), while higher values generate more diverse and creative results (e.g. 1.0). Select a temperature value based on the desired trade-off between coherence and creativity for your specific application. The temperature can range is from 0 to 2.\n\nIs fine-tuning available for the latest models?\n\nYes, for some. Currently, you can only fine-tune gpt-3.5-turbo and our updated base models (babbage-002 and davinci-002). See the fine-tuning guide for more details on how to use fine-tuned models.\n\nDo you store the data that is passed into the API?\n\nAs of March 1st, 2023, we retain your API data for 30 days but no longer use your data sent via the API to improve our models. Learn more in our data usage policy. Some endpoints offer zero retention.\n\nHow can I make my application more safe?\n\nIf you want to add a moderation layer to the outputs of the Chat API, you can follow our moderation guide to prevent content that violates OpenAI’s usage policies from being shown.\n\nShould I use ChatGPT or the API?\n\nChatGPT offers a chat interface to the models in the OpenAI API and a range of built-in features such as integrated browsing, code execution, plugins, and more. By contrast, using OpenAI’s API provides more flexibility."
}